=       Felix Ikechukwu O. Dec 10, 2023       =
= Introduction to object-oriented programming =

Introduction
--------------
an object is a piece of memory to store values created to mimic a sort of model imbued with both properties and behaviours.

Introduction to classes
-----------------------
structs provide a convinient package for storing and moving related data values.

The class invariant problem
---------------------------
the biggest problem of structs us they provide ineffective ways to enforce or document class invariants.

class invariants is a condition that must be true for objects spawned from a class to be remain in a valid state. an object that violates
a class invariant is said to be in an invalid state. an unexpected or undefined behaviour may occur with further of that object.

and relying on users or you the developer to handle class invariants can lead to problematic code. and so
structs do not provide an elegant way of handle class invariants.

Introduction to classes
-----------------------
a class is a program defined compound datatype that can have many memeber variables with different types.
because its a program defined type it must be declared before its used.

classes are similare to structs just that we use the `class` keyword instead of `struct` in its declaration:
{{{cpp
class Employee
{
  int m_id {};
  int m_age {};
  double m_wage {};
};
}}}

example of a class date type:
{{{cpp
#include <iostream>

class Date
{
public:
  int m_day{};
  int m_month{};
  int m_year{};
};

void print_date(Date date)
{
  std::cout << date.m_day << '/' << date.m_month << '/' << date.m_year << '\n';
}

int main()
{
  Date today { 13, 12, 2023 };
  print_date(today);
  return 0;
}
}}}

Most of the C++ standard library is classes
-------------------------------------------
C++ was originally named `C with classes`.


Member functions
================

The separation of properties and actions
----------------------------------------
real life objects posses 2 features about them:
1) observable properties (colour, mass, geometry, etc)
2) number of actions they can perform (fly, bounce, move, etc.)

in programming we represent peoperties with variables and actions with functions.
we can provide class objects with `"actions"` using member functions in the class.

Member functions
----------------
Functions that beloing to class tyoes are known as `member functions`.
functions that are not member functions are known as `non-member functions` or occasonally `free functions` to distinguish them from member functions.
they are declared inside a class defination (as a reminder a defination is alsp a declaration)

A member function example
-------------------------
structs in c++ can have member functions:
{{{cpp
#include <iostream>

struct Date
{
  int day{};
  int month{};
  int year{};

  void print()
  {
    std::cout << day << '/' << month << '/' << year << '\n';
  }
};

int main()
{
  Date today { 12, 12, 2023 };
  ++today.day;
  today.print();

  return 0;
}

}}}

Calling member functions (and the implicit object)
--------------------------------------------------
all non-static mmeber function must be called using an object of the class type the member function belongs to: where it can then access the member variables in the object
(if needed) to exeute the call.

the objects the member function is called on is `implicitly` passed into the member function execution. for this reason the object that the member is called on is often
called `the implicit object`.

in other words: in the above function the call `today.print()`, `today` is an implicit function that is passed into the `print()` function.

Accessing members inside a member function uses the implicit object
-------------------------------------------------------------------
in a member function any member identifier not prefixed with the member selection operator (.) is associated with `the implicit object` (the objects itself).

Another member function example
-------------------------------
{{{cpp
#include <iostream>
#include <string>

struct Person
{
  std::string name {};
  int age{};

  void kissed(Person& person)
  {
    std::cout << name << " kissed " << person.name << '\n';
  }
};

int main()
{
  Person felix { "felix", 21 };
  Person nobody { "nobody", -1 };

  felix.kissed(nobody);

  return 0;
}
}}}

Member variables and functions can be defined in any order
----------------------------------------------------------
for non-member functions the order of declaratiosn matters which is why you cant call  function that hasnt been declared but this limitation does not apply for
member function the order doesnt metter as long as the function to be called will still be defined in the class types declearation.

this is because due to member function being part of a program defined type (class types) that the compiler must always be aware before usage: the compiler already has
a snapshot of all member variables and functions declared in the class type so as long as its declared the compiler will be aware. unlike non-member functions that might
be declared in another trasnslation unit needing a forward declaration to make the compiler aware of it (although its externaly linked).

{{{cpp
struct Foo
{
  int m_x { z() };          // okay to call z() here even tho its not declared: because it still would be
  int m_y { z() };          // same thing as above
  int z() { return 5 };     // declared.
};
}}}

Member functions can be overloaded
----------------------------------
just like non-member functions member function can be overloaded.
{{{cpp
#include <iostream>
#include <string>

struct Date
{
  int m_day   {};
  int m_month {};
  int m_year  {};

  void print()
  {
    std::cout << m_day << '/' << m_month << '/' << m_year << '\n';
  }

  void print( std::string& prefix )
  {
    std::cout << prefix << m_day << '/' << m_month << '/' << m_year << '\n';

  }
};

int main()
{
  Date today { 14, 12, 2023 };

  today.print();                      // calls Date::print()
  std::cout << '\n';

  today.print("The date is: ");       // calls Date::print(std::string_view)
  std::cout << '\n';
}
}}}

Structs and member functions
----------------------------
in C, structs possess no member function unlike in C++.

Bjarne Stroustrup, after many considerations, include it.
A class type with no constructor is considered an aggregate, we want structs to remain aggregates.

Class types with no data members
--------------------------------
its possible.


= Const class objects and const member functions =
==================================================

class objects can be made `const`: they must be initialized uoon creation and its members cannot br modified after creation
this includes:
1) modifying member variables or
2) calling member functions to somehow set the values of member variables.

{{{cpp
struct Date
{
  int year {};
  int month {};
  int day {};

  void incrementDay() { ++day; }
};

int main()
{
  const Date yesterday { 2023, 12, 13 };
  yesterday.incrementDay();                   // compile error: tries to modify member variable `day`.
  yesterday.day++;                            // same: compile error: tries to modify member variable `day`.

  // continue your shitty code here.
}
}}}

Const objects may not call non-const member functions
-----------------------------------------------------
the compiler dosnt allow const objects call non-cont memeber functions.
{{{cpp
struct Date
{
  int year {};
  int month {};
  int day {};

  void print() { std::cout << year << '/' << month << '/' << day; }
};

int main()
{
  const Date today { 2023, 12, 14 };
  today.print();                        // you can't call non-const memeber functions on a const objects. ven if it doesnt moduf any member function its still a violation.
}
}}}

Const member functions
----------------------
meber function can be made const by appending the `const` keyword after the membeer functions parameter list but before the functions body declaration:
{{{cpp
struct Date
{
  int year {};
  int month {};
  int day {};

  void print() const                 // declared: therefore this is a const member function.
  {
    std::cout << year << '/' << month << '/' << day;
  }
};

// now print can be called on a const object spawned from the classes typed struct: Foo
int main()
{
  const Date oneDay { 1193, 11, 3 };
  oneDay.print();                    // valid.
}
}}}

A const member function that attempts to change a member variable or call a non-const member function will cause a compiler error to occur. For example:
{{{cpp
struct Date
{
  int day;
  //...

  void incrementDay() const
  {
    day++;                  // a const function is not allowed to modify a member function: compile error.
  }
};
}}}

Const member functions may be called on non-const objects
---------------------------------------------------------
const member functions can be called on non-const objects (and obvioulsy on const objects) and because of this member functions should usually be declared `const`:
as long as they are not declared or used to modify any member variable, they should be `const`.

Const objects via pass by const reference
-----------------------------------------
the problem with this if we pass a non-const objects into a function, lets call the function `x` , that was declared to take a const object in as a paramter
( `void x (const Date& date)` ), the object will be coerced to be referenced as a const object and the object referenced conatains a non-const memeber function.

Now, if we call the non-const member function on the referenced (coerced to be const) object (due to the functions parameter declaration), in function `x` we will
encounter a compiler error because cons class objects are not allowed to call thier non-const member functions (its illegal).

and this is the problem that may be enocuntered on passing objects via pass by const reference to a function.
this can be prevented though by declaring member functions of a class type, with no intention to modify its member variables, as const.
that way no error is encountered when such member functions is called: regardless of whether the object being called on is of const qualifier or not.

Member function const and non-const overloading
-----------------------------------------------
its possibe to overload member function based on constness. this works because the `const` qualifier is considered part of a functions signature.


= Public and private members and access specifiers =
====================================================

there are three access specifiers in c++ they are:
1) public
2) protetcted
3) private

The members of a struct are public by default
---------------------------------------------
structs by default has its members in public: can be accessd by anyone.
Public can be accessed by other members of the same class and by the `public` (that is code that exist outside the members of a class type.)

The members of a class are private by default
---------------------------------------------
Private members are members that can only accessed by other members of the same class.
and by default members in a class are private.
{{{cpp
#include <iostream>

class Date
{
  int m_year {};              // pirvate by default
  int m_month {};             // private by default
  int m_day {};               // private by default

  void print() const          // private by default
  {
    // member functions can access private members
    std::cout << m_year << '/' << m_month << '/' << m_day;
  }
};

int main()
{
  Date today { 2023, 12, 14 };

  today.m_day = 16;                 // illegal cannot be accessd by the public
  today.print();                    // illegal cannot be accessed by the piblic
}
}}}

Naming your private member variables
------------------------------------
its a common convention to name private data members starting with an `m_` prefix

Setting access levels via access specifiers
-------------------------------------------
by default members of structs and unions are `public` by default and the members of classes are `private` by default.
howwever we can explicitly set the access levels of our members using an `access specifier`:
1) `public:`
2) `private:`
3) `protected:`

an example:
{{{cpp
class Date
{
public:
  void print() const
  {
    std::cout << m_year << '/' << m_month << '/' << m_day;
  }
private:
  int m_year { 2023 };
  int m_month { 12 };
  int m_day { 30 };
};

int main()
{
  Date d{};
  d.print();                      // okay because this is a public function that was used to access private data.
  return 0;
}
}}}

private members can be accessed by the public through private functions.

since classes mmebers default as private: you can declare them without the private specifier when you need them to be private:
{{{cpp
class Foo
{
  int m_something{};             // this is private by default.
};
}}}

Access level best practices for structs and classes
---------------------------------------------------
structs should avoid acccess level specifiers, this is because we want structs to remain as aggregates and aggaregates only posess public members,
and structs members are publicly accessible by default, so theres no need to use specifiers let alone a private specifier which destroys the logic of
structs being aggregates

classes should generally only have private or protected data members, either by specifying (using `private:` or `protected:`) or the default private access level.

Access levels work on a per-class basis
---------------------------------------
onw of the nuance of c++ access levels that is often misunderstood is that access of members is defined per class basis and not per object basis:
what this means is that member functions are not just limited to `thier` accessing private members but they can also access the privtate members of `ANY` other objects of
thier class type that is in scope.

{{{cpp
#include <iostream>
#include <string>
#include <string_view>

class Person
{
private:
  std::string_view m_name {};

public:
  void kisses(const Person& p) const
  {
    std::cout << m_name << " kisses " << p.m_name << '\n';
  }
  void setName(std::string_view name)
  {
    m_name = name
  }
};

int main()
{
  Person joe;
  joe.setName("Joe");

  Person kate;
  kate.setName("Kate");

  joe.kisees(kate);       // ths compiles successfuclly and executes accurately: this tells us that public methods can access the private members of even other objects
  // of the same type.
}
}}}

becaues our class has private members: its not an aggregate meaning it cannot be initialized using aggregate initializations, as a workaround we provide a public
function that can used to access private members.

public member functions have the access to private member functions anf also the private member functions of other objects of the same type as long as they are in scope.

The technical and practical difference between structs and classes
------------------------------------------------------------------
structs defaules its members to be `public` while classes default its members as `private`. thats the only difference (i think)

we use structs when the following are true:
1) we hava a simple collecstion of data that does no benefit from being inaccessible by the public
2) aggregate initialization is sufficient
3) there are no class invariants, setup needs or cleanup needs

if any the above are not true, you should likely use a class
we want out structs to be aggregates, so if any capablity that is non-aggregate in nature is required: one should opt for classes instead of structs.


`Access functions`
================
an `access` function is a trivial member function of a class whose job is to retreive or change the value of a private member.
they come in 2 flavors:
1) getters
2) setters

getters sometimes called `accessors` and setters which are sometimes called `mutators`.

Getters :: public member functions that return the value of private memvber variables.
Setters :: public member functions that set the value of a private member variable.

Getters are usually made const so they can be called on both const and non-const objects
Setters should be non const so they can modify the data members.

for illustative purposes the Date class updated:
{{{cpp
#include <iostream>

class Date
{
private:
  int m_year { 2020 };
  int m_month { 12 };
  int m_day { 23 };

public:
  int getYear() const { return m_year; }        // getter for year
  int setYear(int year) { m_year = year; }      // setter for month

  int getMonth() const { return m_month; }      // getter for month
  int setMonth(int month) { m_month = month; }  // setter for month

  int getDay() const { return m_day; }          // getter for year
  int setDay(int day) { m_day = day; }          // setter for month
};

int main()
{
  Date d{};
  d.setYear(2024);
  std::cout << "The year is: " << d.getYear() << '\n';
}
}}}

Access function naming
----------------------
1) use the `get` or `set` prefixes for the identifers of the getters and setters respectively
2) or only use the `set` prefix for a setter and the normal identifier with no prefix for the `getter`

Getters should return by value or by const lvalue reference
-----------------------------------------------------------
getters should only provide `read-only`access to data. meaning they should only return by value or const lvalue refernce.

Only provide access functions in cases where the public would reasonably need to get or set the value of an individual member.

Why make data private if we’re going to provide a public access functions to it?
--------------------------------------------------------------------------------
this well be answered in future notes (i hope)


`Member functions returning references to data members`
=====================================================

Introduction
------------
its safe for memmber functions to return members with const lvalue reference: this is because sine that members of an object posses the same lifetime as their implicit object that they are called retrieved
or accessed from then its quite (likely) immpossible for one to return a dangling reference of a memeber from its object.

and the reason we use retunr by const lvalue reference is because (sometimes) copt return can be quite expensive especially if the size of the data to be return is large.
{{{cpp
#include <iostream>
#include <string>

class Employee
{
private:
  std::string m_name {};

public:
  void setName(string_view name) { m_name = name; }
  const std::string& getName() const { return m_name; }       // getter returns by const reference.
};

int main()
{
  Employee Joe {};
  joe.setName("Joe");
  std::cout << joe.getName << '\n';
}
}}}

The return type of a member function returning a reference to a data member should match the data member’s type
---------------------------------------------------------------------------------------------------------------
for getter using `auto` is a convennient way to allow th compiler deduce the type of the data to be returned and prevent implicit conversions
{{{cpp
class Employee
{
private:
  std::string name{};

public:
  const auto& getaName() const { return name; }       // now he compiler makes sure this function returns a reference to the deduced type of the data to be returned.
  // ---
};
  // ---
}}}

however returning with the `auto` keywords  kind of obscures the type of string type that is returned: is it `C-style strings?`, `string_views?`, `strings?` or somehing else entierely?
this is why we mostly explicitly state the type of sntring we want to be returned.

Rvalue implicit objects and return by reference
-----------------------------------------------
recalll that rvalues are destroyed at the end of the expressions they are declared in so returning rvalue implicit objects into a referenced can prove to be problematic
bcacuse well be handling a dangling reference: this is because the object being an rvalue will be destroyed at the end of the ecpression which includes its members too (theyll be destroyed also)
so accessing them through a reference will be result to UB becauee after that expression the implicit object and its objects no longer exists (they have been destroyed).

an example exploring this concept
{{{cpp
#include <ioatream>
#include <string>
#include <string_view>

class Employee
{
private:
  std::string m_name{};

public:
  void setName(std::string_view name) { m_name = name; }
  const std::string& getName() const { return name; }
};

Employee createEmployee( std::string_view name )
{
  Employee e;
  e.setName( name );
  return e;
}

int main()
{
  // case 1: using the returned rvalue before the statement ends: OK. its legal
  std::cout << createEmployee("Zuriel").getName() << '\n';

  // case 2: trying to save a returned rvalue into a reference for later use with the mindset that it'll still be a reference to a valid object: NOT OK. its illegal
  // : implicit rvalue objects die at the end of the expression its used in.
  const std::string& ref { createEmployee("Naomi").getName() };
  std::cout << ref ;      // undefined behaviour.

  // case 3: storing the retunrned rvalue into a normal vairable of the same type (not a reference): OK. its legal: this is because the rvalue is passed by copy and after being copied its destroyed.
  const std::string name { createEmployee("Hedwig").getName() };
  std::cout << name << '\n';  // still legal.
}

}}}

Using member functions that return by reference safely
------------------------------------------------------
blah blah blah...

Do not return non-const references to private data members
----------------------------------------------------------
this is quite obvious why: with non-const reference we can edit the the value of an object includeing private members which defeats the point of setters and the member being private itself
and even the non-aggregate nature classes are supposed to be distinguished by.

Const member functions can’t return non-const references to data members
------------------------------------------------------------------------
A const member function is not alowed to return non-const member functions to members. this makes sense  a const member function is not allowed to modify the state of am object.



`The benefits of data hiding (encapsulation)`
===========================================
read this shit yourself.

Prefer non-member functions to member functions
-----------------------------------------------
if a function can be implelemeted as a non-member function: prefer this than actually implemeting member functions.
for the reason consult the site bish.


`Introduction to constructors`
============================

when a class tyoe is an aggregate we use can use agreggate intialization to initialize them directly like on structs.
Aggregate initialization do member wise initialization and initialize its members in the order they are declared.
Hoever when we make our members private we can no longer use aggregate initialization be cause aggregates cant have private members like in the class-type `class`.

if we try to use the aggregate initialization to initialize aggregates we get the compiler error:
`“error: no matching constructor for initialization of ‘Foo'”`

meaning we need a constructor, but what are they?

Constructors
------------
a constructor is a function that is called immediately called after a non-aggregate class type object is created.

we use constructors to initialzae member variables ot perform some initialization action. constructors do not create objects: the compiler allocates memory for the objects
prior to calling the constructror: once a  constructor is done executed we can say that the object is now `constructed`.

Naming constructors
-------------------
unlike normal member functrions constructors have specifiec rule or how they should be declared and named:
1) they must have the same name or identifier as the class they belong to
2) they are not to have any return type not even void

basic constructors example:
{{{cpp
class Point
{
private:
  int m_x{};
  int m_y{};
public:
  Point(int x, int y)
  {
    m_x = x;
    m_y = y;
  }

  void print()
  {
    std::cout << m_x << ':' << m_y << '\n';
  }
};

int main()
{
  Point point { 10, 56 };
  point.print();
}
}}}

constructors should not be `const`: this is because it needs to modify member variables which cannot be achieved if `const`


`Constructor member initializer lists`
====================================
to allow constructors initialize member variable we can use the `member initialization list`.
{{{cpp
#include <iostream>

class Foo
{
private:
  int m_x {};
  int m_y {};
public:
  Foo(int x, int y)
    : m_x { x } , m_y { y }
  {
    std::cout << "Foo(" << x << ", " << y << ") constructed\n";
  }

  void print() const
  {
    std::cout << "Foo(" << m_x << ", " << m_y << ")\n";
  }
};

int main()
{
  Foo foo { 6, 7 };
  foo.print();
}
}}}

Member initialization order
---------------------------
the c++ standard says the members should be initialized in the order they are declared: meaning defining costructer member initilizeer lists to initialize in the wrong order can be problematic:
case example:
{{{cpp
#include <iostream>
#include <algorithm>

class Foo
{
private:
  int m_one {};
  int m_two {};
public:
  Foo(int x, int y) : m_y { std::max(x, y) }, m_x { m_y }
  {
  }

  void print() const
  {
    std::cout << "Foo(" << m_x << ", " << m_y << ")\n";
  }
};

int main()
{
  Foo foo { 5, 6 };
  foo.print();
}
}}}

on my mcahine it prints:
`Foo(0, 6)`

which isnt supposed to be, but this happrns because:
* the compiler tries to initialize m_one first: this is becaue it was declared first
* since it was declared to initialize m_one with m_two it proceed to do and because m_two hasent being initialized yet
  by its constructor it refers back to its zero initialization when it was first declared and returns 0.
* therby initializing m_one with zero
* Now its time for m_two to be initialized it finds the max of 5 and 6 and uses the result to initialize itself
* thus making m_two possess the value 6.

to prevent thus member variables in a member list constructor initilizer should be initialized in the order they are declared.

Member initializer list vs default member initializers
------------------------------------------------------
Members can be initialized in a few different ways:

1)    If a member is listed in the member initializer list, that initialization value is used
2)    Otherwise, if the member has a default member initializer, that initialization value is used
3)    Otherwise, the member is default initialized

Constructor function bodies
---------------------------
Prefer using the member initializer list to initialize your members over assigning values in the body of the constructor.
{{{cpp
#include <iostream>
#define NOT_INIT

class Foo
{
private:
  int m_x{};
  int m_y{};
public:
#ifdef NOT_INIT
  Foo(int x, int y)
  {
    m_x = x;                // this is not initialization, this is an assignment: wont always work
    m_y = y;                // this is not initialization, this is an assignment: wont always work
  }
#else
  Foo(int x, int y)
    : m_x { x }, m_y { y }  // this is initialization (constructor list initialization)
  {
    // body of constrictor can be left empty if it was intended ton be used for member initialized only.
  }
#endif

  void print() const
  {
    std::cout << "Foo(" << m_x << ", " << m_y << ")\n";
  }
};

int main() { }
}}}


`Default constructors and default arguments`
==========================================

a default constructor is a constructor that accpets no argument. typically its a constructor that has been defined with no paramters.
{{{cpp
class Foo
{
public:
  Foo()       // thus is a default constructor
  [
    std::cout << "Foo is a default constructer";
  ]
}
}}}

Value initialization vs default initialization for class types
--------------------------------------------------------------
we should prefere value initialization to default initialization because safer for aggregates and since its difficult to tell by glance if a class tyoe is an aggregate or not
its safer to use `value initialization`.
{{{cpp
Foo foo{};      // value init.tion    : still calls constructor
Foo foo2;       // default init.tion  : still calls constructor
}}}

Constructors with default arguments
-----------------------------------
just as normal function: constructors can have default arguments:
{{{cpp
class Foo
{
private:
  int m_x {};
  int m_y {};
public:
  Foo(int x=0, int y=0) : m_x { x },  m_y { y }
  {
  }
};
}}}

if all the paramters of a constructor has default arguments then the constructor is a default constructor becaule it can be called with no arguments

Overloaded constructors
-----------------------
constructors can be overloaded:
{{{cpp
class Foo
{
private:
  int m_x {};
  int m_y {};
public:
  Foo()
  {
    std::cout << "this shit has been constructed bitch" << '\n';
  }

  Foo(int x, int y) : m_x { x }, m_y { y }
  {
    std::cout << "Foo(" << x << ", " << y << ") constructed\n";
  }
};
}}}

despite we can do this classes should only have one conctructor:
    this is becasue if the compiler encounters an ambigous constructor call and doesnt know which
    constructor to call in the event that mutiple constructors exists that can handle the same call: a compiler error is thrown

An implicit default constructor
-------------------------------
if a non-aggregate class tyoe is declared without a constructor the compiler gemerates one for it. this generated constructor is known as an:
`implicit default constructor`.

Using `= default` to generate a default constructor
-------------------------------------------------
in cases were would write a default constructor that is similar to the imeplicitly generated default contructor we can tell the compiler to generate
an implicit default constructor for use by using the following syntax:
{{{cpp
class Foo
{
private:
  int m_x {};
  int m_y {};

public:
  Foo() = default;

  Foo(int x, int y)
    : m_x { x }, m_y { y }
  {
    std::cout << "Foo(" << x << ", " << y << ") constructed\n";
  }
};

int main()
{
  Foo foo {};   // calls Foo() default constructor.
  return 0;
}

}}}

Implicit default constructor vs empty user constructor
------------------------------------------------------
Prefer an explicitly defaulted default constructor (=default) over a default constructor with an empty body.


`Delegating constructors`
=======================
constructors are allowed to call other functions including member functions
constructors are not designed to be called from the body of another function (including other constructors)

but contructors are akllowed to transfer redponsibility of initialization to another constructor of the same class type, this is known as constructor chaining
and such constructors are known as deleagting constructors.

an example of constructor delegating:
{{{cpp
#include <iostream>
#include <string>
#include <string_view>

class Employee
{
private:
  std::string m_name {};
  int m_id { 0 };
public:
  Employee(std:string_view name)
    : Employee{ name, 0 }                               // delegates initilialization to Emplpoyee(std::string_view, int) constructor
  {
  }

  Employee(std::string_view name, int id)
    : m_name { name }, m_id { id }                      // actually initializes the members
  {
    std::cout << "Employee " << m_name << " created\n";
  }
};
}}}

a few notes on deleagting constructors:
1) they are not alowwed to initialize members themeselves: so your constructors can either initialize or deleagte but not both.
2) also constructors can delegate to another comstructor that delegates back to its delegator: causing an inifinite loop of deleagation thereby making your stack run out of memory
   crrashing your program

Reducing constructors using default arguments
---------------------------------------------
Default values help to reduce multiple constructors into few constructors. for example by using default values we can initialize objects with fewer arguments because the
unspecified defaulted arguments can fall back to the default values laid out for thier constructor and be constructed with no issue.

A conundrum: Redundant constructors vs redundant default values
---------------------------------------------------------------
read this conundrum yourself.


`Temporary class objects`
=======================

this are anonymous rvalue objects with no name that posses a lifetime equal to the duration of the exoression they are declared in.
they are also known as `temporary objects`, `anonymous objects` or `unamed objects`.

wasys of creating anonymous objeects:
{{{cpp

class IntPair
{
private:
  int m_x {};
  int m_y {};
publci:
  IntPair(int x, int y) : m_x { x }, m_y { y }
  { }

  int x() const { return  m_x };
  int y() const { return  m_y };
};

void print(IntPair& x)
{
  std::cout << "(" << p.x() << ", " << p.y() << ")\n";
}

int main()
{
  // case 1: not a temporary object
  IntPair p { 2, 3 };
  print( p );

  // case 2: a temporary object no name
  print( IntPair { 4, 5 } );

  // case 3: also a temporary object no type or name since its values are still gog to be stored in the functions parameter which is of type IntPair
  print( { 6, 7 } );

  return 0;
}
}}}

we can also use temporary objects in functions return:
{{{cpp
#include <iostream>

class IntPair
{
  // previous IntPair class declaration here
};

void print(IntPair p)
{
  std::cout << "(" << p.x() << ", " << p.y() << ")\n";
}

// case 1: not an anonymous return
IntPair ret1()
{
  IntPair p { 1, 2 };
  return p
}

// case 2: an anonymous object return : no name
IntPair ret2()
{
  return IntPair { 3, 4 };
}

// case 3: an anonymous object return: no name, no explicitly declared type. allows the compiler implicitlty convert the values into the return type of the function
IntPair ret3()
{
  return { 5, 6 };
}

int main()
{
  print( ret1() );
  print( ret2() );
  print( ret3() );

  return 0;
}
}}}

A few notes
-----------
1) a temporaty object is an rvalue and its can only be used where rvalues can be used.
2) temporary objects are created at the point of defination and are destoroyed at the end of a full expression not a sub-expression.


`Introduction to the copy constructor`
====================================

Introduction
------------
a copy constructor is a constructor that is used to initialize an objects with the member of another object of the same class type, adter a copy constructors is executed
the copy object should be a copy of the object passed in as an initializer.

An implicit copy constructor
----------------------------
read this: it does memberwise initializaton construction and its implicit in nature so need to define yours

Defining your own copy constructor
----------------------------------
it takes in a reference of an object of the same type and initializes its members with the members of the passed in object member_wisely.
{{{cpp
#include <iostream>

class Fraction
{
private:
  int m_n { 0 };
  int m_d { 1 };
private:
  Fraction (int n=0, int d=1)
    : m_n { n }
    , m_d { d }
  { }

  Fraction(const Fraction& f)                                 // this is a copy constructor
    : m_n { f.m_n }
    , m_d { f.m_d }
  { }

  void print() const
  {
    std::cout << "Fraction(" << m_numerator << ", " << m_denominator << ")\n";
  }
};

int main()
{
  Fraction f { 2, 3 };
  Fraction fCopy { f };                 // Fraction (const Fraction&) is called: this is a copy constructor.
  return 0;
}
}}}

copy constructors should have no side effects more than copying. if your relying on the copy constructor for other actions than copying that behaviour might not occur.

<!--NOTE: PREFER DEFAULT COPY CONSTRUCTORS TO THAT OF THOSE YOU DEFINE YOURSELF -->

The copy constructor’s parameter must be a reference
----------------------------------------------------
mmmmhmm. a `const lvalue reference` to be precise.

Pass by value (and return by value) and the copy constructor
------------------------------------------------------------
when an objects is passed by value the argumnet is copied into the paramter and when the argument an parameter are of the same class the copy constructor is invoked
making a copy. similarly the same process applies when an object is returned back to its caller by value. all this processs have one thing in common: they all make copies.
will be explained in details later.

Pass by value (and return by value) and the copy constructor
------------------------------------------------------------
if a class had no cpy constructor its implicitly gemerated by the compiler we can explicitly requst the compiler create a default constructor for us using the `= default` syntax.

{{{cpp
#include <iostream>

class Fraction
{
private:
    int m_numerator{ 0 };
    int m_denominator{ 1 };

public:
    // Default constructor
    Fraction(int numerator=0, int denominator=1)
        : m_numerator{numerator}, m_denominator{denominator}
    {
    }

    // Explicitly request default copy constructor
    Fraction(const Fraction& fraction) = default;

    void print() const
    {
        std::cout << "Fraction(" << m_numerator << ", " << m_denominator << ")\n";
    }
};
}}}

Using = delete to prevent copies
--------------------------------
occassionaly we can run into scenarios where we dont wnt certain class objects to be copy-able we can prevent that using the `= delete` syntax.
{{{cpp

class Fraction
{
  // before implementions here: check above codes
public:
  Fraction (const Fraction& fraction) = delete;                         // makes it impossible for the copy constructor to be called.
  // after implementions here: check above codes
};

int main()
{
  Fraction f { 1, 2 };
  Fraction fCopy { f };                                                 // compiler error: copy constructor cant be called so copies cannot be made.
}
}}}

For advanced readers (which i am not yet : o)
---------------------------------------------
`the rule three` of c++ states that if a class requires a `user-defined copy constructor`, `destructor` or `copy assignement operator`, then it probably requires all three.
this was later expanded to the `rule of five`, which adds the `move constructor` and `move assignment operator` to the list.


`Class initialization and copy elision`
=====================================

in modern c++ `copy`, `direct` and `list` initiaization generally do the same thing: they initialize an object.

For all types of initialization:
1) when initializeing a class type sets of constructors of the class are examined and the best matching is use to initialize the object.
2) when initializaing a non-class type, implicit conversion rules are use to determimine whether an implicit conversion exitsts.

There are three key differences between the initialization forms:
-----------------------------------------------------------------
1) List initialization dissalows narrowing conversions
2) copy initialization only considers non-explicit constructors/ consversion functions.
3) List initialization prioritizes matching list constructors over matching constructors.

Unnecessary copies
------------------
when we make needless ineffecient declarations in our coude the compiler is free to reformat them to make them more efficient
this is what is done by the compiler when we make needless copies using the copy constructor: this is known as `copy elision`

